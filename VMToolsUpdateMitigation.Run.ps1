#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: a349aebf-aa8d-4077-9941-4717958f103a
# Source File: C:\Users\dalthakar\OneDrive\Script_Projects\VMWareToolsMitigation\VMToolsUpdateMitigation.psproj
#------------------------------------------------------------------------
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
     Generated on:       1/29/2020 10:02 AM
     Generated by:       dalthakar
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2018
#>



#region Source: Startup.pss
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
[void][Reflection.Assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
#endregion Import Assemblies

#Define a Param block to use custom parameters in the project
#Param ($CustomParameter)

function Main {
<#
    .SYNOPSIS
        The Main function starts the project application.
    
    .PARAMETER Commandline
        $Commandline contains the complete argument string passed to the script packager executable.
    
    .NOTES
        Use this function to initialize your script and to call GUI forms.
		
    .NOTES
        To get the console output in the Packager (Forms Engine) use: 
		$ConsoleOutput (Type: System.Collections.ArrayList)
#>
	Param ([String]$Commandline)
		
	#--------------------------------------------------------------------------
	#TODO: Add initialization script here (Load modules and check requirements)
	
	
	#--------------------------------------------------------------------------
	
	if((Show-MainForm_psf) -eq 'OK')
	{
		
	}
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}







#endregion Source: Startup.pss

#region Source: Globals.ps1
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	
	
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{
	<#
		.SYNOPSIS
			Get-ScriptDirectory returns the proper location of the script.
	
		.OUTPUTS
			System.String
		
		.NOTES
			Returns the correct path within a packaged executable.
	#>
		[OutputType([string])]
		param ()
		if ($null -ne $hostinvocation)
		{
			Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	
	#Sample variable that provides the location of the script
	[string]$ScriptDirectory = Get-ScriptDirectory
	
	Set-ExecutionPolicy -Scope Process -ExecutionPolicy Unrestricted -Force
	
	# Set the log directory.
	[string]$docsDirectory = [Environment]::GetFolderPath('MyDocuments')
	$logGUID = New-Guid
	[string]$logParentDirectory = "$docsDirectory\vmware_tools_mitigation"
	[string]$logDirectory = "$docsDirectory\vmware_tools_mitigation\$logGUID"
	
	if (-not (Get-Item -Path $logGUID)) { New-Item -ItemType Directory -Path "$logParentDirectory" -Name $logGUID }
	
	# Import all functions.
	
	foreach ($item in (Get-ChildItem -Path "$ScriptDirectory\Functions\" | ?{ $_.Extension -eq ".ps1" }))
	{
		. "$($item.FullName)"
	}
	
	if (-not (Get-ChildItem "$logParentDirectory\prereqsinstalled.log" -ErrorAction SilentlyContinue))
	{
		Install-PreReqs | Out-File "$logParentDirectory\prereqsinstalled.log"
	}
	
	#Credential object for vCenter authentication.
	if (Get-Item -Path "$($env:TEMP)\vcCreds.xml")
	{
		$vcCredential = Import-Clixml -Path "$($env:TEMP)\vcCreds.xml"
	}
	else
	{
		$vcCredential = $null
	}
	
	#vCenter connection object.
	$vcenterConnection = $null
	
	#vCenter Server Name
	if (Get-Item -Path "$($env:TEMP)\vcServer.xml")
	{
		$vcServer = Import-Clixml -Path "$($env:TEMP)\vcServer.xml"
	}
	else
	{
		$vcServer = $null
	}
	
	#VM Folder array
	$vmFolderArray = @()
	
	#Windows Update Credential
	$updateCred
	
	# Selected ISO file
	$vmToolsISO
#endregion Source: Globals.ps1

#region Source: MainForm.psf
function Show-MainForm_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$formVMToolsMitigation = New-Object 'System.Windows.Forms.Form'
	$buttonCancel = New-Object 'System.Windows.Forms.Button'
	$buttonBack = New-Object 'System.Windows.Forms.Button'
	$buttonFinish = New-Object 'System.Windows.Forms.Button'
	$tabcontrolWizard = New-Object 'System.Windows.Forms.TabControl'
	$tabpageStep1 = New-Object 'System.Windows.Forms.TabPage'
	$labelStep1 = New-Object 'System.Windows.Forms.Label'
	$vcenterTextbox = New-Object 'System.Windows.Forms.TextBox'
	$labelVCenterFQDNOrIPAddre = New-Object 'System.Windows.Forms.Label'
	$panel1 = New-Object 'System.Windows.Forms.Panel'
	$labelOKStep1 = New-Object 'System.Windows.Forms.Label'
	$labelConnectionStatusNotC = New-Object 'System.Windows.Forms.Label'
	$labelUsernameNotConnected = New-Object 'System.Windows.Forms.Label'
	$labelVCenterServerNotConn = New-Object 'System.Windows.Forms.Label'
	$labelSetVSphereCredential = New-Object 'System.Windows.Forms.Label'
	$buttonEnterCredentials = New-Object 'System.Windows.Forms.Button'
	$pictureboxLoading = New-Object 'System.Windows.Forms.PictureBox'
	$tabpageStep2 = New-Object 'System.Windows.Forms.TabPage'
	$radiobuttonRunFullReport = New-Object 'System.Windows.Forms.RadioButton'
	$radiobuttonModifyACLs = New-Object 'System.Windows.Forms.RadioButton'
	$buttonSetUpdateCredential = New-Object 'System.Windows.Forms.Button'
	$buttonRun = New-Object 'System.Windows.Forms.Button'
	$listboxVMUpdateList = New-Object 'System.Windows.Forms.ListBox'
	$listboxVMList = New-Object 'System.Windows.Forms.ListBox'
	$checkboxSelectAll = New-Object 'System.Windows.Forms.CheckBox'
	$comboboxDatacenter = New-Object 'System.Windows.Forms.ComboBox'
	$labelDatacenter = New-Object 'System.Windows.Forms.Label'
	$labelVMFolder = New-Object 'System.Windows.Forms.Label'
	$comboboxVMFolders = New-Object 'System.Windows.Forms.ComboBox'
	$buttonDeleteVMFromQueue = New-Object 'System.Windows.Forms.Button'
	$buttonAddVirtualMachines = New-Object 'System.Windows.Forms.Button'
	$labelStep2 = New-Object 'System.Windows.Forms.Label'
	$buttonNext = New-Object 'System.Windows.Forms.Button'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	#-------------------------------------------------------
	# NOTE: When new TabPage added place the validation code
	# 		in the Test-WizardPage function.
	#-------------------------------------------------------
	function Test-WizardPage
	{
	<#
		Add TabPages and place the validation code in this function
	#>
		[OutputType([boolean])]
		param([System.Windows.Forms.TabPage]$tabPage)
		
		if($tabPage -eq $tabpageStep1)
		{
			if (-not $global:vcenterConnection.IsConnected)
			{
				return $false
			}
			else
			{
				return $true
			}
		}
		elseif ($tabPage -eq $tabpageStep2)
		{
			#TODO: Enter Validation Code here for Step 2
			if ($listboxVMUpdateList.Items)
			{
				return $true
			}
			
			return $false
		}
		#Add more pages here
		
		return $false
	}
	
	function Enable-UpdateButton
	{
		if ($radiobuttonModifyACLs.Checked)
		{
			if ($global:updateCred -and $listboxVMUpdateList.Items -and $radiobuttonModifyACLs.Checked)
			{
				$buttonRun.Enabled = $true
				$buttonRun.BackColor = 'Green'
			}
			else
			{
				$buttonRun.Enabled = $false
				$buttonRun.BackColor = 'Red'
			}
			
			$buttonRun.Text = "Modify ACLs"
			
			$comboboxVMFolders.Enabled = $true
			$comboboxDatacenter.Enabled = $true
			$labelStep2.Text = "Step 2: Select VMs to modify ACLs."
			
			if (-not ($comboboxVMFolders.Items))
			{
				# Clear the items in the VM folder combobox.
				
				$comboboxVMFolders.Items.Clear()
				
				# Here, we determine the built-in 'vm' folder's ID so we can exclude it from the list.
				
				$parentID = ""
				$folder1 = Get-Folder -Type VM -Name vm -Location (Get-Datacenter $comboboxDatacenter.Text)
				
				if ($folder1.ParentID -eq (Get-Datacenter).Id)
				{
					$parentID = $folder1.Id
				}
				
				# Now, let's grab all the folders and list them (excluding sub-folders).
				
				$folders = Get-Folder -Type VM | ?{ $_.ParentId -eq $parentID } | Select Name | Sort-Object | % { $comboboxVMFolders.Items.Add($_.Name) }
			}
		}
		elseif ($radiobuttonRunFullReport.Checked)
		{
			$buttonRun.Enabled = $true
			
			$buttonRun.Text = "Run Report"
			$buttonRun.BackColor = 'Green'
			
			$listboxVMList.Items.Clear()
			$listboxVMUpdateList.Items.Clear()
			
			$comboboxVMFolders.Enabled = $false
			$comboboxVMFolders.Items.Clear()
			
			$comboboxDatacenter.Enabled = $false
			
			$labelStep2.Text = "Step 2: Run report against the logged on vCenter."
		}
		else
		{
			$buttonRun.Enabled = $false
			$buttonRun.BackColor = 'Red'
		}
	}
	
	
	$buttonFinish_Click={
		#-------------------------------------------------------
		# TODO: Place finalization script here
		#-------------------------------------------------------
		
	}
	
	#region Events and Functions
	$formVMToolsMitigation_Load={
		Update-NavButtons
		
		[bool]$nonNumberEntered = $false
		$Path = $env:TEMP
		
		if (Get-Item "$Path\VcenterHistory\vcenterhistory.log")
		{
			$autoCompleteArray = (Import-Csv "$Path\VcenterHistory\vcenterhistory.log").vcenter
			
			$vcenterTextbox.AutoCompleteCustomSource.AddRange($autoCompleteArray)
		}
		
		if ($global:vcServer)
		{
			$vcenterTextbox.Text = $global:vcServer
			$vcenterTextbox.Enabled = $false
		}
		
		if ($global:vcCredential)
		{
			$waitProcess = Start-Process -FilePath "$ScriptDirectory\Plugins\WaitPage.exe" -PassThru
			try
			{
				$global:vcenterConnection = Connect-VIServer -Server $global:vcServer -Credential $global:vcCredential -ErrorAction Stop
				
				if ($global:vcenterConnection.IsConnected)
				{
					$labelVCenterServerNotConn.Text = "vCenter Server: $($vcenterTextbox.Text)"
					$labelUsernameNotConnected.Text = "Username: $($global:vcenterConnection.User)"
					$labelConnectionStatusNotC.Text = "Connection Status: Connected"
					$labelOKStep1.Visible = $true
					
					$buttonEnterCredentials.Enabled = $false
					
					$rootDCs = Get-Datacenter -Server $global:vcenterConnection.Name | Sort-Object Name
					
					$rootDCs | Out-File "$logDirectory\dcs.log"
					
					foreach ($root in $rootDCs)
					{
						$comboboxDatacenter.Items.Add($root.Name)
					}
					
					Stop-Process $waitProcess.Id
					$tabcontrolWizard.SelectedTab = $tabpageStep2
					Update-NavButtons
				}
			}
			catch
			{
				Stop-Process $waitProcess.Id
				[System.Windows.Forms.MessageBox]::Show("Unable to connect to $($vcenterTextbox.Text). Please try logging on again.")
				$vcenterTextbox.Enabled = $true
				$buttonEnterCredentials.Enabled = $false
			}
		}
	}
	
	function Update-NavButtons
	{
		<# 
			.DESCRIPTION
			Validates the current tab and Updates the Next, Prev and Finish buttons.
		#>
		$enabled = Test-WizardPage $tabcontrolWizard.SelectedTab
		$buttonNext.Enabled = $enabled -and ($tabcontrolWizard.SelectedIndex -lt $tabcontrolWizard.TabCount - 1)
		$buttonBack.Enabled = $tabcontrolWizard.SelectedIndex -gt 0
		$buttonFinish.Enabled = $enabled -and ($tabcontrolWizard.SelectedIndex -eq $tabcontrolWizard.TabCount - 1)	
		#Uncomment to Hide Buttons
		#$buttonNext.Visible = ($tabcontrolWizard.SelectedIndex -lt $tabcontrolWizard.TabCount - 1)
		#$buttonFinish.Visible = ($tabcontrolWizard.SelectedIndex -eq $tabcontrolWizard.TabCount - 1)
	}
	
	$script:DeselectedIndex = -1
	$tabcontrolWizard_Deselecting=[System.Windows.Forms.TabControlCancelEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TabControlCancelEventArgs]
		# Store the previous tab index
		$script:DeselectedIndex = $_.TabPageIndex
	}
	
	$tabcontrolWizard_Selecting=[System.Windows.Forms.TabControlCancelEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TabControlCancelEventArgs]
		# We only validate if we are moving to the Next TabPage. 
		# Users can move back without validating
		if($script:DeselectedIndex -ne -1 -and $script:DeselectedIndex -lt $_.TabPageIndex)
		{
			#Validate each page until we reach the one we want
			for($index = $script:DeselectedIndex; $index -lt $_.TabPageIndex; $index++)
			{
				$_.Cancel = -not (Test-WizardPage $tabcontrolWizard.TabPages[$index])
				
				if($_.Cancel) 
				{
					# Cancel and Return if validation failed.
					return;
				}
			}
		}
		
		Update-NavButtons
	}
	
	$buttonBack_Click={
		#Go to the previous tab page
		if($tabcontrolWizard.SelectedIndex -gt 0)
		{
			$tabcontrolWizard.SelectedIndex--
		}
	}
	
	$buttonNext_Click={	
		#Go to the next tab page
		if($tabcontrolWizard.SelectedIndex -lt $tabcontrolWizard.TabCount - 1)
		{
			$tabcontrolWizard.SelectedIndex++
		}
	}
	
	#endregion
	
	$buttonEnterCredentials_Click={
		
		try
		{
			$pictureboxLoading.Visible = $true
			if ($global:vcenterConnection.IsConnected)
			{
				Disconnect-VIServer -Server * -Force -Confirm:$false
				$labelVCenterServerNotConn.Text = "vCenter Server: Not Connected"
				$labelUsernameNotConnected.Text = "Username: Not Connected"
				$labelConnectionStatusNotC.Text = "Connection Status: Not Connected"
			}
			$connected = $false
			$global:vcCredential = $null
			$global:vcenterConnection = $null
			$global:vcCredential = Get-Credential -Message "Please enter your vSphere credentials." -ErrorAction Stop
			$waitProcess = Start-Process -FilePath "$ScriptDirectory\Plugins\WaitPage.exe" -PassThru
			$global:vcenterConnection = Connect-VIServer -Server $vcenterTextbox.Text -Credential $global:vcCredential -ErrorAction Stop
			$buttonEnterCredentials.Enabled = $false
			$pictureboxLoading.Visible = $false
			
		}
		catch
		{
			"Unable to connect."
		}
		
		If ($global:vcenterConnection.IsConnected)
		{
			$labelVCenterServerNotConn.Text = "vCenter Server: $($vcenterTextbox.Text)"
			$labelUsernameNotConnected.Text = "Username: $($global:vcenterConnection.User)"
			$labelConnectionStatusNotC.Text = "Connection Status: Connected"
			$labelOKStep1.Visible = $true
			$vcenterTextbox.Enabled = $false
			
			$Path = $env:TEMP
			
			if (-not (Get-Item "$Path\VcenterHistory" -ErrorAction SilentlyContinue))
			{
				New-Item -Name VcenterHistory -Path $Path -ItemType Directory
			}
			
			if (Get-Item "$Path\VcenterHistory\vcenterhistory.log" -ErrorAction SilentlyContinue)
			{
				$vcHistoryArray = Import-Csv "$Path\VcenterHistory\vcenterhistory.log"
				
				$vcHistoryArray = $vcHistoryArray | ?{ $_.vcenter -ne "$($vcenterTextbox.Text)" }
				
				$object = New-Object PSObject
				
				$object | Add-Member -MemberType NoteProperty -Name vcenter -Value $vcenterTextbox.Text
				
				$vcHistoryArray = [System.Array]$vcHistoryArray + $object
				
				$vcHistoryArray | Export-CSV "$Path\VcenterHistory\vcenterhistory.log" -NoTypeInformation
			}
			else
			{
				$vcHistoryArray = @()
				
				$object = New-Object PSObject
				
				$object | Add-Member -MemberType NoteProperty -Name vcenter -Value $vcenterTextbox.Text
				
				$vcHistoryArray = [System.Array]$vcHistoryArray + $object
				
				$vcHistoryArray | Export-CSV "$Path\VcenterHistory\vcenterhistory.log" -NoTypeInformation
			}
			
			$rootDCs = Get-Datacenter -Server $global:vcenterConnection.Name | Sort-Object Name
			
			foreach ($root in $rootDCs)
			{
				$comboboxDatacenter.Items.Add($root.Name)
			}
			
			Stop-Process -Id $waitProcess.Id
			Update-NavButtons
			
		}
		else
		{
			Stop-Process -Id $waitProcess.Id
			[System.Windows.Forms.MessageBox]::Show("Unable to connect to $($vcenterTextbox.Text). Please try logging on again.")
			$labelOKStep1.Visible = $false
			Update-NavButtons
		}
	}
	
	$vcenterTextbox_TextChanged={
		
		if ($vcenterTextbox.Text -ne "")
		{
			$buttonEnterCredentials.Enabled = $true
		}
		else
		{
			$buttonEnterCredentials.Enabled = $false
		}
		
	}
	
	#region Control Helper Functions
	function Update-ComboBox
	{
	<#
		.SYNOPSIS
			This functions helps you load items into a ComboBox.
		
		.DESCRIPTION
			Use this function to dynamically load items into the ComboBox control.
		
		.PARAMETER ComboBox
			The ComboBox control you want to add items to.
		
		.PARAMETER Items
			The object or objects you wish to load into the ComboBox's Items collection.
		
		.PARAMETER DisplayMember
			Indicates the property to display for the items in this control.
		
		.PARAMETER Append
			Adds the item(s) to the ComboBox without clearing the Items collection.
		
		.EXAMPLE
			Update-ComboBox $combobox1 "Red", "White", "Blue"
		
		.EXAMPLE
			Update-ComboBox $combobox1 "Red" -Append
			Update-ComboBox $combobox1 "White" -Append
			Update-ComboBox $combobox1 "Blue" -Append
		
		.EXAMPLE
			Update-ComboBox $combobox1 (Get-Process) "ProcessName"
		
		.NOTES
			Additional information about the function.
	#>
		
		param
		(
			[Parameter(Mandatory = $true)]
			[ValidateNotNull()]
			[System.Windows.Forms.ComboBox]
			$ComboBox,
			[Parameter(Mandatory = $true)]
			[ValidateNotNull()]
			$Items,
			[Parameter(Mandatory = $false)]
			[string]
			$DisplayMember,
			[switch]
			$Append
		)
		
		if (-not $Append)
		{
			$ComboBox.Items.Clear()
		}
		
		if ($Items -is [Object[]])
		{
			$ComboBox.Items.AddRange($Items)
		}
		elseif ($Items -is [System.Collections.IEnumerable])
		{
			$ComboBox.BeginUpdate()
			foreach ($obj in $Items)
			{
				$ComboBox.Items.Add($obj)
			}
			$ComboBox.EndUpdate()
		}
		else
		{
			$ComboBox.Items.Add($Items)
		}
		
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	function Update-ListBox
	{
	<#
		.SYNOPSIS
			This functions helps you load items into a ListBox or CheckedListBox.
		
		.DESCRIPTION
			Use this function to dynamically load items into the ListBox control.
		
		.PARAMETER ListBox
			The ListBox control you want to add items to.
		
		.PARAMETER Items
			The object or objects you wish to load into the ListBox's Items collection.
		
		.PARAMETER DisplayMember
			Indicates the property to display for the items in this control.
		
		.PARAMETER Append
			Adds the item(s) to the ListBox without clearing the Items collection.
		
		.EXAMPLE
			Update-ListBox $ListBox1 "Red", "White", "Blue"
		
		.EXAMPLE
			Update-ListBox $listBox1 "Red" -Append
			Update-ListBox $listBox1 "White" -Append
			Update-ListBox $listBox1 "Blue" -Append
		
		.EXAMPLE
			Update-ListBox $listBox1 (Get-Process) "ProcessName"
		
		.NOTES
			Additional information about the function.
	#>
		
		param
		(
			[Parameter(Mandatory = $true)]
			[ValidateNotNull()]
			[System.Windows.Forms.ListBox]
			$ListBox,
			[Parameter(Mandatory = $true)]
			[ValidateNotNull()]
			$Items,
			[Parameter(Mandatory = $false)]
			[string]
			$DisplayMember,
			[switch]
			$Append
		)
		
		if (-not $Append)
		{
			$listBox.Items.Clear()
		}
		
		if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
		{
			$listBox.Items.AddRange($Items)
		}
		elseif ($Items -is [System.Collections.IEnumerable])
		{
			$listBox.BeginUpdate()
			foreach ($obj in $Items)
			{
				$listBox.Items.Add($obj)
			}
			$listBox.EndUpdate()
		}
		else
		{
			$listBox.Items.Add($Items)
		}
		
		$listBox.DisplayMember = $DisplayMember
	}
	
	function Update-ListViewColumnSort
	{
	<#
		.SYNOPSIS
			Sort the ListView's item using the specified column.
		
		.DESCRIPTION
			Sort the ListView's item using the specified column.
			This function uses Add-Type to define a class that sort the items.
			The ListView's Tag property is used to keep track of the sorting.
		
		.PARAMETER ListView
			The ListView control to sort.
		
		.PARAMETER ColumnIndex
			The index of the column to use for sorting.
		
		.PARAMETER SortOrder
			The direction to sort the items. If not specified or set to None, it will toggle.
		
		.EXAMPLE
			Update-ListViewColumnSort -ListView $listview1 -ColumnIndex 0
		
		.NOTES
			Additional information about the function.
	#>
		
		param
		(
			[Parameter(Mandatory = $true)]
			[ValidateNotNull()]
			[System.Windows.Forms.ListView]
			$ListView,
			[Parameter(Mandatory = $true)]
			[int]
			$ColumnIndex,
			[System.Windows.Forms.SortOrder]
			$SortOrder = 'None'
		)
		
		if (($ListView.Items.Count -eq 0) -or ($ColumnIndex -lt 0) -or ($ColumnIndex -ge $ListView.Columns.Count))
		{
			return;
		}
		
		#region Define ListViewItemComparer
		try
		{
			[ListViewItemComparer] | Out-Null
		}
		catch
		{
			Add-Type -ReferencedAssemblies ('System.Windows.Forms') -TypeDefinition  @" 
	using System;
	using System.Windows.Forms;
	using System.Collections;
	public class ListViewItemComparer : IComparer
	{
	    public int column;
	    public SortOrder sortOrder;
	    public ListViewItemComparer()
	    {
	        column = 0;
			sortOrder = SortOrder.Ascending;
	    }
	    public ListViewItemComparer(int column, SortOrder sort)
	    {
	        this.column = column;
			sortOrder = sort;
	    }
	    public int Compare(object x, object y)
	    {
			if(column >= ((ListViewItem)x).SubItems.Count)
				return  sortOrder == SortOrder.Ascending ? -1 : 1;
		
			if(column >= ((ListViewItem)y).SubItems.Count)
				return sortOrder == SortOrder.Ascending ? 1 : -1;
		
			if(sortOrder == SortOrder.Ascending)
	        	return String.Compare(((ListViewItem)x).SubItems[column].Text, ((ListViewItem)y).SubItems[column].Text);
			else
				return String.Compare(((ListViewItem)y).SubItems[column].Text, ((ListViewItem)x).SubItems[column].Text);
	    }
	}
"@ | Out-Null
		}
		#endregion
		
		if ($ListView.Tag -is [ListViewItemComparer])
		{
			#Toggle the Sort Order
			if ($SortOrder -eq [System.Windows.Forms.SortOrder]::None)
			{
				if ($ListView.Tag.column -eq $ColumnIndex -and $ListView.Tag.sortOrder -eq 'Ascending')
				{
					$ListView.Tag.sortOrder = 'Descending'
				}
				else
				{
					$ListView.Tag.sortOrder = 'Ascending'
				}
			}
			else
			{
				$ListView.Tag.sortOrder = $SortOrder
			}
			
			$ListView.Tag.column = $ColumnIndex
			$ListView.Sort() #Sort the items
		}
		else
		{
			if ($SortOrder -eq [System.Windows.Forms.SortOrder]::None)
			{
				$SortOrder = [System.Windows.Forms.SortOrder]::Ascending
			}
			
			#Set to Tag because for some reason in PowerShell ListViewItemSorter prop returns null
			$ListView.Tag = New-Object ListViewItemComparer ($ColumnIndex, $SortOrder)
			$ListView.ListViewItemSorter = $ListView.Tag #Automatically sorts
		}
	}
	
	
	function Add-ListViewItem
	{
	<#
		.SYNOPSIS
			Adds the item(s) to the ListView and stores the object in the ListViewItem's Tag property.
	
		.DESCRIPTION
			Adds the item(s) to the ListView and stores the object in the ListViewItem's Tag property.
	
		.PARAMETER ListView
			The ListView control to add the items to.
	
		.PARAMETER Items
			The object or objects you wish to load into the ListView's Items collection.
			
		.PARAMETER  ImageIndex
			The index of a predefined image in the ListView's ImageList.
		
		.PARAMETER  SubItems
			List of strings to add as Subitems.
		
		.PARAMETER Group
			The group to place the item(s) in.
		
		.PARAMETER Clear
			This switch clears the ListView's Items before adding the new item(s).
		
		.EXAMPLE
			Add-ListViewItem -ListView $listview1 -Items "Test" -Group $listview1.Groups[0] -ImageIndex 0 -SubItems "Installed"
	#>
		
		Param( 
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[System.Windows.Forms.ListView]$ListView,
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		$Items,
		[int]$ImageIndex = -1,
		[string[]]$SubItems,
		$Group,
		[switch]$Clear)
		
		if($Clear)
		{
			$ListView.Items.Clear();
	    }
	    
	    $lvGroup = $null
	    if ($Group -is [System.Windows.Forms.ListViewGroup])
	    {
	        $lvGroup = $Group
	    }
	    elseif ($Group -is [string])
	    {
	        #$lvGroup = $ListView.Group[$Group] # Case sensitive
	        foreach ($groupItem in $ListView.Groups)
	        {
	            if ($groupItem.Name -eq $Group)
	            {
	                $lvGroup = $groupItem
	                break
	            }
	        }
	        
	        if ($null -eq $lvGroup)
	        {
	            $lvGroup = $ListView.Groups.Add($Group, $Group)
	        }
	    }
	    
		if($Items -is [Array])
		{
			$ListView.BeginUpdate()
			foreach ($item in $Items)
			{		
				$listitem  = $ListView.Items.Add($item.ToString(), $ImageIndex)
				#Store the object in the Tag
				$listitem.Tag = $item
				
				if($null -ne $SubItems)
				{
					$listitem.SubItems.AddRange($SubItems)
				}
				
				if($null -ne $lvGroup)
				{
					$listitem.Group = $lvGroup
				}
			}
			$ListView.EndUpdate()
		}
		else
		{
			#Add a new item to the ListView
			$listitem  = $ListView.Items.Add($Items.ToString(), $ImageIndex)
			#Store the object in the Tag
			$listitem.Tag = $Items
			
			if($null -ne $SubItems)
			{
				$listitem.SubItems.AddRange($SubItems)
			}
			
			if($null -ne $lvGroup)
			{
				$listitem.Group = $lvGroup
			}
		}
	}
	
	#endregion
	
	$buttonAddVirtualMachines_Click={
		
		$checkboxSelectAll.Checked = $false
		
		# Check to see if all items are selected. If SelectedItems property of the listBox is blank, assume all items.
		if ($listboxVMList.SelectedItems)
		{
			foreach ($item in $listboxVMList.SelectedItems)
			{
				if ($item -notin $listboxVMUpdateList.Items)
				{
					Update-ListBox -ListBox $listboxVMUpdateList -Items $item -Append
				}
			}
		}
		else
		{
			foreach ($item in $listboxVMList.Items)
			{
				if ($item -notin $listboxVMUpdateList.Items)
				{
					Update-ListBox -ListBox $listboxVMUpdateList -Items $item -Append
				}
			}
		}
		
		$buttonDeleteVMFromQueue.Enabled = $true
		
		Enable-UpdateButton
		
		Update-NavButtons
		
	}
	
	$buttonDeleteVMFromQueue_Click={
		
		$index = $listboxVMUpdateList.SelectedIndex
		$listboxVMUpdateList.Items.RemoveAt($index)
		
		if (-not $listboxVMUpdateList.Items)
		{
			$buttonDeleteVMFromQueue.Enabled = $false
			Enable-UpdateButton
		}
		else
		{
			$listboxVMUpdateList.SelectedIndex = 0
		}
		
		Update-NavButtons
	}
	
	$listviewVMsStep2_SelectedIndexChanged={
		
		$buttonDeleteVMFromQueue.Enabled = $true
		
	}
	
	$buttonRun_Click={
		
		$waitProcess = Start-Process -FilePath "$ScriptDirectory\Plugins\WaitPage.exe" -PassThru -NoNewWindow
		
		$datetime = Get-Date -Format "MMddyyyy_HH_mm_ss"
		$userName = $env:USERNAME
		$archiveName = ""
		
		try
		{
			$vmList = $listboxVMUpdateList.Items
			$vmList | Out-File "$logDirectory\vmlist.log"
			
			if ($radiobuttonModifyACLs.Checked)
			{
				foreach ($vm in $vmList)
				{
					while (@(Get-Job | ?{ $_.State -eq "Running" }).Count -ge 25)
					{
						# We're going to iterate through the running jobs and kill any that have been running for X minutes.
						# This block is ignored if there are less than 5 total builds. We'll handle that part later.
						
						Write-Host "Waiting for open thread...($NumJobs Maximum)"
						Start-Sleep -Seconds 2
					}
					
					Start-Job -Name $vm -ArgumentList $vcenterTextbox.Text, $global:vcCredential, $ScriptDirectory, `
							  $logDirectory, $vm, $global:updateCred -Verbose -ScriptBlock {
						
						Import-Module VMware.PowerCLI
						$connection = Connect-VIServer -Server $args[0] -Credential $args[1] -ErrorAction Stop
						
						Invoke-VMScript -VM (Get-VM $args[4]) -GuestCredential $args[5] -ScriptText {
							if (-not (Get-Item -Path "C:\Scripts"))
							{
								New-Item -ItemType Directory -Path "C:\" -Name "Scripts"
							}
							
							if (-not (Get-Item -Path "C:\Scripts\vmtoolslog"))
							{
								New-Item -ItemType Directory -Path "C:\Scripts" -Name "vmtoolslog"
							}
						}
						
						Invoke-VMScript -VM (Get-VM $args[4]) -GuestCredential $args[5] -ScriptText {
							
							$scriptString = '
				
						$domain = $ENV:USERDOMAIN
						$dir = "C:\ProgramData\VMware\VMware CAF"
						$logdir = "C:\Scripts\vmtoolslog"
						$compName = (Get-ComputerInfo).CsDnsHostName
						$acl = Get-ACL $dir
						$acl.SetAccessRuleProtection($True, $True)
						Set-ACL -AclObject $acl -Path $dir -confirm:$false
						
						$acl2 = Get-ACL $dir
						foreach ($access in $acl2.Access)
						{
							foreach ($value in $access.IdentityReference.Value)
							{
								if (($value -eq "BUILTIN\USERS") `
									-or ($value -eq "$domain\Users"))
								{
									$acl2.RemoveAccessRule($access)
								}
							}
						}

						Set-ACL -AclObject $acl2 -Path $dir -confirm:$false					
						'
							
							$scriptString | Out-File "C:\Scripts\ModifyACLs.ps1" -Force
							
							Set-Location -Path "C:\Scripts"
							
							if (-not (Get-Item -Path 'C:\ProgramData\VMware\VMware CAF' -ErrorAction Continue))
							{
								mkdir 'C:\ProgramData\VMware\VMware CAF'
							}
							
							(Get-Acl -Path 'C:\ProgramData\VMware\VMware CAF').Access
							
							# Specify the account to run the script
							$User = "NT AUTHORITY\SYSTEM"
							# Specify what program to run and with its parameters
							$Action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-NonInteractive -NoLogo -NoProfile -ExecutionPolicy Bypass C:\Scripts\ModifyACLs.ps1"
							# Specify the name of the task
							Register-ScheduledTask -TaskName "ModifyVMACLs" -User $User -Action $Action -RunLevel Highest –Force -ErrorAction Stop
							
							Start-ScheduledTask -TaskName "ModifyVMACLs" -ErrorAction Stop
							
							while ((Get-ScheduledTask -TaskName "ModifyVMACLs").State -ne "Ready")
							{
								Start-Sleep -Seconds 1
							}
							
							Unregister-ScheduledTask -TaskName "ModifyVMACLs" -Confirm:$false
							
							(Get-Acl -Path 'C:\ProgramData\VMware\VMware CAF').Access
							
						}
					
						Disconnect-VIServer -Server $args[0] -Force -Confirm:$false -ErrorAction Stop
						
					} # End Start-Job block
					
				} # End foreach loop
			} # End IF statement
			elseif ($radiobuttonRunFullReport.Checked)
			{
				Get-VM | ?{ $_.Guest -like "*windows*" } | Select-Object -Property Name, @{ Name = 'ToolsVersion'; Expression = { $_.Guest.ToolsVersion } } | Export-CSV "$logDirectory\VMWareToolsReport.csv" -NoTypeInformation
			}
			
			# We'll kill any jobs that have been running for longer than X minutes.
			# For each job returned that has not completed, we'll check to see if it has been running longer than X minutes. If it has, kill the job.
			do
			{
				Start-Sleep -Milliseconds 1000
				
				foreach ($job in (Get-Job))
				{
					$runTime = ((Get-Date) - $job.PSBeginTime).Minutes
					if ($runtime -gt 30)
					{
						try
						{
							Stop-Job $job.Name -Confirm:$false
						}
						catch
						{
							"Unable to stop job."
						}
					}
				}
				
			}
			while ((Get-Job -State Running).Count -gt 0)
			
			# Get the completed jobs.
			$jobs = Get-Job | ?{ $_.State -eq "Completed" }
			
			# Get the failed jobs.
			$failedJobs = Get-Job | ?{ $_.State -ne "Completed" }
			
			# Output the job results to a separate log file for each VM.		
			$data = @()
			
			foreach ($job in $jobs)
			{
				$data = Get-Job $job.Name | Receive-Job
				Remove-Job $job
				
				$job.Name | Out-File "$logDirectory\$($job.Name)_jobresult.log"
				$data | Out-File "$logDirectory\$($job.Name)_jobresult.log"
			}
			
			$failedData = @()
			
			foreach ($failedJob in $failedJobs)
			{
				$failedData += Get-Job $failedJob.Name | Receive-Job
				Remove-Job $failedJob
			}
			
			Stop-Process -Id $waitProcess.Id
			if (-not $failedData)
			{
				[System.Windows.Forms.MessageBox]::Show("VM Tools mitigation steps completed.")
				$formVMToolsMitigation.Close()
			}
			else
			{
				$failedData | Out-File "$logDirectory\jobresult_failed.log" -Append
				[System.Windows.Forms.MessageBox]::Show("The following virtual machine data transfers failed: $failedData")
				$formVMToolsMitigation.Close()
			}
			
			$files = Get-ChildItem -Path $logDirectory -Filter "*.xlsx"
			
			if ($radiobuttonModifyACLs.Checked)
			{
				$archiveName = "ModifyACLs_$datetime.zip"
			}
			elseif ($radiobuttonRunFullReport.Checked)
			{
				$archiveName = "VMToolsReport_$datetime.zip"
			}
			
			Compress-Archive -Path $logDirectory -DestinationPath "$logParentDirectory\$archiveName" -Verbose -Force
			Remove-Item -Path $logDirectory -Recurse -Confirm:$false
		}
		catch
		{
			Stop-Process -Id $waitProcess.Id
			[System.Windows.Forms.MessageBox]::Show("Unable to modify virtual machines.")		
		}
	}
	
	$checkboxSelectAll_CheckedChanged={
		
		if ($checkboxSelectAll.Checked)
		{
			for ($i = 0; $i -lt $listboxVMList.Items.Count; $i++)
			{
				$listboxVMList.SetSelected($i, $true)
			}
		}
		elseif (-not $checkboxSelectAll.Checked)
		{
			for ($i = 0; $i -le ($listboxVMList.Items.Count - 1); $i++)
			{
				$listboxVMList.SetSelected($i, $false)
			}
		}
	}
	
	$comboboxDatacenter_SelectedIndexChanged={
		
		# Clear the items in the VM folder combobox.
		
		$comboboxVMFolders.Items.Clear()
		
		# Here, we determine the built-in 'vm' folder's ID so we can exclude it from the list.
		
		$parentID = ""
		$folder1 = Get-Folder -Type VM -Name vm -Location (Get-Datacenter $comboboxDatacenter.Text)
		
		if ($folder1.ParentID -eq (Get-Datacenter).Id)
		{
			$parentID = $folder1.Id
		}
		
		# Now, let's grab all the folders and list them (excluding sub-folders).
		
		$folders = Get-Folder -Type VM | ?{ $_.ParentId -eq $parentID } | Select Name | Sort-Object | % { $comboboxVMFolders.Items.Add($_.Name) }	
	}
	
	$comboboxVMFolders_SelectedIndexChanged={
		
		$listboxVMList.Items.Clear()
		
		$vms = Get-VM -Location $comboboxVMFolders.Text | Where-Object { ($_.Guest.ToolsVersion -like "*10*") -and ($_.GuestID -Like "*windows*") -and ($_.PowerState -eq "PoweredOn") } |  Sort-Object
		
		if ($vms)
		{
			Update-ListBox -ListBox $listboxVMList -Items $vms.Name
			$checkboxSelectAll.Enabled = $true
		}
		else
		{
			$checkboxSelectAll.Enabled = $false
		}	
	}
	
	$listboxVMList_SelectedIndexChanged={
		
		$buttonAddVirtualMachines.Enabled = $true
	}
	
	$buttonSetUpdateCredential_Click={
		
		$message = "Enter the LOCAL administrator account that will be used to run commands on the selected VMs."
		$global:updateCred = (Get-Credential -Message $message)
		
		Enable-UpdateButton
		
	}
	
	$radiobuttonModifyACLs_CheckedChanged={
		
		Enable-UpdateButton
	}
	
	$radiobuttonRunFullReport_CheckedChanged={
		
		Enable-UpdateButton
	}
	
	# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$formVMToolsMitigation.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:MainForm_vcenterTextbox = $vcenterTextbox.Text
		$script:MainForm_radiobuttonRunFullReport = $radiobuttonRunFullReport.Checked
		$script:MainForm_radiobuttonModifyACLs = $radiobuttonModifyACLs.Checked
		$script:MainForm_listboxVMUpdateList = $listboxVMUpdateList.SelectedItems
		$script:MainForm_listboxVMList = $listboxVMList.SelectedItems
		$script:MainForm_checkboxSelectAll = $checkboxSelectAll.Checked
		$script:MainForm_comboboxDatacenter = $comboboxDatacenter.Text
		$script:MainForm_comboboxDatacenter_SelectedItem = $comboboxDatacenter.SelectedItem
		$script:MainForm_comboboxVMFolders = $comboboxVMFolders.Text
		$script:MainForm_comboboxVMFolders_SelectedItem = $comboboxVMFolders.SelectedItem
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$buttonBack.remove_Click($buttonBack_Click)
			$buttonFinish.remove_Click($buttonFinish_Click)
			$vcenterTextbox.remove_TextChanged($vcenterTextbox_TextChanged)
			$buttonEnterCredentials.remove_Click($buttonEnterCredentials_Click)
			$radiobuttonRunFullReport.remove_CheckedChanged($radiobuttonRunFullReport_CheckedChanged)
			$radiobuttonModifyACLs.remove_CheckedChanged($radiobuttonModifyACLs_CheckedChanged)
			$buttonSetUpdateCredential.remove_Click($buttonSetUpdateCredential_Click)
			$buttonRun.remove_Click($buttonRun_Click)
			$listboxVMList.remove_SelectedIndexChanged($listboxVMList_SelectedIndexChanged)
			$checkboxSelectAll.remove_CheckedChanged($checkboxSelectAll_CheckedChanged)
			$comboboxDatacenter.remove_SelectedIndexChanged($comboboxDatacenter_SelectedIndexChanged)
			$comboboxVMFolders.remove_SelectedIndexChanged($comboboxVMFolders_SelectedIndexChanged)
			$buttonDeleteVMFromQueue.remove_Click($buttonDeleteVMFromQueue_Click)
			$buttonAddVirtualMachines.remove_Click($buttonAddVirtualMachines_Click)
			$tabcontrolWizard.remove_Selecting($tabcontrolWizard_Selecting)
			$tabcontrolWizard.remove_Deselecting($tabcontrolWizard_Deselecting)
			$buttonNext.remove_Click($buttonNext_Click)
			$formVMToolsMitigation.remove_Load($formVMToolsMitigation_Load)
			$formVMToolsMitigation.remove_Load($Form_StateCorrection_Load)
			$formVMToolsMitigation.remove_Closing($Form_StoreValues_Closing)
			$formVMToolsMitigation.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch { Out-Null <# Prevent PSScriptAnalyzer warning #> }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$formVMToolsMitigation.SuspendLayout()
	$tabcontrolWizard.SuspendLayout()
	$tabpageStep1.SuspendLayout()
	$panel1.SuspendLayout()
	$tabpageStep2.SuspendLayout()
	#
	# formVMToolsMitigation
	#
	$formVMToolsMitigation.Controls.Add($buttonCancel)
	$formVMToolsMitigation.Controls.Add($buttonBack)
	$formVMToolsMitigation.Controls.Add($buttonFinish)
	$formVMToolsMitigation.Controls.Add($tabcontrolWizard)
	$formVMToolsMitigation.Controls.Add($buttonNext)
	$formVMToolsMitigation.AcceptButton = $buttonFinish
	$formVMToolsMitigation.AutoScaleDimensions = '6, 13'
	$formVMToolsMitigation.AutoScaleMode = 'Font'
	$formVMToolsMitigation.CancelButton = $buttonCancel
	$formVMToolsMitigation.ClientSize = '689, 455'
	$formVMToolsMitigation.FormBorderStyle = 'FixedDialog'
	$formVMToolsMitigation.MaximizeBox = $False
	$formVMToolsMitigation.Name = 'formVMToolsMitigation'
	$formVMToolsMitigation.StartPosition = 'CenterScreen'
	$formVMToolsMitigation.Text = 'VM Tools Mitigation'
	$formVMToolsMitigation.add_Load($formVMToolsMitigation_Load)
	#
	# buttonCancel
	#
	$buttonCancel.Anchor = 'Bottom, Right'
	$buttonCancel.DialogResult = 'Cancel'
	$buttonCancel.Location = '521, 420'
	$buttonCancel.Name = 'buttonCancel'
	$buttonCancel.Size = '75, 23'
	$buttonCancel.TabIndex = 4
	$buttonCancel.Text = '&Cancel'
	$buttonCancel.UseCompatibleTextRendering = $True
	$buttonCancel.UseVisualStyleBackColor = $True
	#
	# buttonBack
	#
	$buttonBack.Anchor = 'Bottom, Left'
	$buttonBack.Location = '13, 420'
	$buttonBack.Name = 'buttonBack'
	$buttonBack.Size = '75, 23'
	$buttonBack.TabIndex = 1
	$buttonBack.Text = '< &Back'
	$buttonBack.UseCompatibleTextRendering = $True
	$buttonBack.UseVisualStyleBackColor = $True
	$buttonBack.add_Click($buttonBack_Click)
	#
	# buttonFinish
	#
	$buttonFinish.Anchor = 'Bottom, Right'
	$buttonFinish.DialogResult = 'OK'
	$buttonFinish.Location = '602, 420'
	$buttonFinish.Name = 'buttonFinish'
	$buttonFinish.Size = '75, 23'
	$buttonFinish.TabIndex = 3
	$buttonFinish.Text = '&Finish'
	$buttonFinish.UseCompatibleTextRendering = $True
	$buttonFinish.UseVisualStyleBackColor = $True
	$buttonFinish.add_Click($buttonFinish_Click)
	#
	# tabcontrolWizard
	#
	$tabcontrolWizard.Controls.Add($tabpageStep1)
	$tabcontrolWizard.Controls.Add($tabpageStep2)
	$tabcontrolWizard.Anchor = 'Top, Bottom, Left, Right'
	$tabcontrolWizard.Location = '13, 12'
	$tabcontrolWizard.Name = 'tabcontrolWizard'
	$tabcontrolWizard.SelectedIndex = 0
	$tabcontrolWizard.Size = '664, 402'
	$tabcontrolWizard.TabIndex = 0
	$tabcontrolWizard.add_Selecting($tabcontrolWizard_Selecting)
	$tabcontrolWizard.add_Deselecting($tabcontrolWizard_Deselecting)
	#
	# tabpageStep1
	#
	$tabpageStep1.Controls.Add($labelStep1)
	$tabpageStep1.Controls.Add($vcenterTextbox)
	$tabpageStep1.Controls.Add($labelVCenterFQDNOrIPAddre)
	$tabpageStep1.Controls.Add($panel1)
	$tabpageStep1.Controls.Add($pictureboxLoading)
	$tabpageStep1.Location = '4, 22'
	$tabpageStep1.Name = 'tabpageStep1'
	$tabpageStep1.Padding = '3, 3, 3, 3'
	$tabpageStep1.Size = '656, 376'
	$tabpageStep1.TabIndex = 0
	$tabpageStep1.Text = 'Step 1 - vCenter Login'
	$tabpageStep1.UseVisualStyleBackColor = $True
	#
	# labelStep1
	#
	$labelStep1.AutoSize = $True
	$labelStep1.Font = 'Microsoft Sans Serif, 12pt, style=Bold'
	$labelStep1.Location = '6, 9'
	$labelStep1.Name = 'labelStep1'
	$labelStep1.Size = '470, 24'
	$labelStep1.TabIndex = 8
	$labelStep1.Text = 'Step 1: Enter your vCenter server and credentials to proceed.'
	$labelStep1.UseCompatibleTextRendering = $True
	#
	# vcenterTextbox
	#
	$vcenterTextbox.AutoCompleteMode = 'Append'
	$vcenterTextbox.AutoCompleteSource = 'CustomSource'
	$vcenterTextbox.Location = '166, 49'
	$vcenterTextbox.Name = 'vcenterTextbox'
	$vcenterTextbox.Size = '161, 20'
	$vcenterTextbox.TabIndex = 6
	$vcenterTextbox.add_TextChanged($vcenterTextbox_TextChanged)
	#
	# labelVCenterFQDNOrIPAddre
	#
	$labelVCenterFQDNOrIPAddre.AutoSize = $True
	$labelVCenterFQDNOrIPAddre.Location = '6, 52'
	$labelVCenterFQDNOrIPAddre.Name = 'labelVCenterFQDNOrIPAddre'
	$labelVCenterFQDNOrIPAddre.Size = '153, 17'
	$labelVCenterFQDNOrIPAddre.TabIndex = 5
	$labelVCenterFQDNOrIPAddre.Text = 'vCenter FQDN or IP Address:'
	$labelVCenterFQDNOrIPAddre.UseCompatibleTextRendering = $True
	#
	# panel1
	#
	$panel1.Controls.Add($labelOKStep1)
	$panel1.Controls.Add($labelConnectionStatusNotC)
	$panel1.Controls.Add($labelUsernameNotConnected)
	$panel1.Controls.Add($labelVCenterServerNotConn)
	$panel1.Controls.Add($labelSetVSphereCredential)
	$panel1.Controls.Add($buttonEnterCredentials)
	$panel1.Location = '6, 82'
	$panel1.Name = 'panel1'
	$panel1.Size = '321, 288'
	$panel1.TabIndex = 7
	#
	# labelOKStep1
	#
	$labelOKStep1.AutoSize = $True
	$labelOKStep1.Font = 'Comic Sans MS, 10.125pt, style=Bold'
	$labelOKStep1.ForeColor = 'Green'
	$labelOKStep1.Location = '197, 134'
	$labelOKStep1.Name = 'labelOKStep1'
	$labelOKStep1.Size = '28, 24'
	$labelOKStep1.TabIndex = 38
	$labelOKStep1.Text = 'OK!'
	$labelOKStep1.UseCompatibleTextRendering = $True
	$labelOKStep1.Visible = $False
	#
	# labelConnectionStatusNotC
	#
	$labelConnectionStatusNotC.AutoSize = $True
	$labelConnectionStatusNotC.Location = '13, 137'
	$labelConnectionStatusNotC.Name = 'labelConnectionStatusNotC'
	$labelConnectionStatusNotC.Size = '178, 17'
	$labelConnectionStatusNotC.TabIndex = 4
	$labelConnectionStatusNotC.Text = 'Connection Status: Not Connected'
	$labelConnectionStatusNotC.UseCompatibleTextRendering = $True
	#
	# labelUsernameNotConnected
	#
	$labelUsernameNotConnected.AutoSize = $True
	$labelUsernameNotConnected.Location = '13, 100'
	$labelUsernameNotConnected.Name = 'labelUsernameNotConnected'
	$labelUsernameNotConnected.Size = '138, 17'
	$labelUsernameNotConnected.TabIndex = 3
	$labelUsernameNotConnected.Text = 'Username: Not Connected'
	$labelUsernameNotConnected.UseCompatibleTextRendering = $True
	#
	# labelVCenterServerNotConn
	#
	$labelVCenterServerNotConn.AutoSize = $True
	$labelVCenterServerNotConn.Location = '13, 68'
	$labelVCenterServerNotConn.Name = 'labelVCenterServerNotConn'
	$labelVCenterServerNotConn.Size = '162, 17'
	$labelVCenterServerNotConn.TabIndex = 2
	$labelVCenterServerNotConn.Text = 'vCenter Server: Not Connected'
	$labelVCenterServerNotConn.UseCompatibleTextRendering = $True
	#
	# labelSetVSphereCredential
	#
	$labelSetVSphereCredential.AutoSize = $True
	$labelSetVSphereCredential.Dock = 'Fill'
	$labelSetVSphereCredential.Location = '0, 0'
	$labelSetVSphereCredential.Name = 'labelSetVSphereCredential'
	$labelSetVSphereCredential.Size = '127, 17'
	$labelSetVSphereCredential.TabIndex = 1
	$labelSetVSphereCredential.Text = 'Set vSphere Credentials'
	$labelSetVSphereCredential.UseCompatibleTextRendering = $True
	#
	# buttonEnterCredentials
	#
	$buttonEnterCredentials.Enabled = $False
	$buttonEnterCredentials.Location = '13, 168'
	$buttonEnterCredentials.Name = 'buttonEnterCredentials'
	$buttonEnterCredentials.Size = '114, 23'
	$buttonEnterCredentials.TabIndex = 0
	$buttonEnterCredentials.Text = 'Enter Credentials'
	$buttonEnterCredentials.UseCompatibleTextRendering = $True
	$buttonEnterCredentials.UseVisualStyleBackColor = $True
	$buttonEnterCredentials.add_Click($buttonEnterCredentials_Click)
	#
	# pictureboxLoading
	#
	$pictureboxLoading.Anchor = 'Bottom, Right'
	#region Binary Data
	$pictureboxLoading.Image = [System.Convert]::FromBase64String('
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
Cwg1RAAAOwAAAAAAAAAAAA==')
	#endregion
	$pictureboxLoading.Location = '595, 340'
	$pictureboxLoading.Name = 'pictureboxLoading'
	$pictureboxLoading.Size = '68, 68'
	$pictureboxLoading.TabIndex = 9
	$pictureboxLoading.TabStop = $False
	$pictureboxLoading.Visible = $False
	#
	# tabpageStep2
	#
	$tabpageStep2.Controls.Add($radiobuttonRunFullReport)
	$tabpageStep2.Controls.Add($radiobuttonModifyACLs)
	$tabpageStep2.Controls.Add($buttonSetUpdateCredential)
	$tabpageStep2.Controls.Add($buttonRun)
	$tabpageStep2.Controls.Add($listboxVMUpdateList)
	$tabpageStep2.Controls.Add($listboxVMList)
	$tabpageStep2.Controls.Add($checkboxSelectAll)
	$tabpageStep2.Controls.Add($comboboxDatacenter)
	$tabpageStep2.Controls.Add($labelDatacenter)
	$tabpageStep2.Controls.Add($labelVMFolder)
	$tabpageStep2.Controls.Add($comboboxVMFolders)
	$tabpageStep2.Controls.Add($buttonDeleteVMFromQueue)
	$tabpageStep2.Controls.Add($buttonAddVirtualMachines)
	$tabpageStep2.Controls.Add($labelStep2)
	$tabpageStep2.Location = '4, 22'
	$tabpageStep2.Name = 'tabpageStep2'
	$tabpageStep2.Padding = '3, 3, 3, 3'
	$tabpageStep2.Size = '656, 376'
	$tabpageStep2.TabIndex = 1
	$tabpageStep2.Text = 'Step 2 - VM Selection'
	$tabpageStep2.UseVisualStyleBackColor = $True
	#
	# radiobuttonRunFullReport
	#
	$radiobuttonRunFullReport.Location = '273, 46'
	$radiobuttonRunFullReport.Name = 'radiobuttonRunFullReport'
	$radiobuttonRunFullReport.Size = '152, 24'
	$radiobuttonRunFullReport.TabIndex = 37
	$radiobuttonRunFullReport.TabStop = $True
	$radiobuttonRunFullReport.Text = 'Get VM Tools Versions'
	$radiobuttonRunFullReport.UseCompatibleTextRendering = $True
	$radiobuttonRunFullReport.UseVisualStyleBackColor = $True
	$radiobuttonRunFullReport.add_CheckedChanged($radiobuttonRunFullReport_CheckedChanged)
	#
	# radiobuttonModifyACLs
	#
	$radiobuttonModifyACLs.Location = '273, 82'
	$radiobuttonModifyACLs.Name = 'radiobuttonModifyACLs'
	$radiobuttonModifyACLs.Size = '104, 24'
	$radiobuttonModifyACLs.TabIndex = 36
	$radiobuttonModifyACLs.TabStop = $True
	$radiobuttonModifyACLs.Text = 'Modify ACLs'
	$radiobuttonModifyACLs.UseCompatibleTextRendering = $True
	$radiobuttonModifyACLs.UseVisualStyleBackColor = $True
	$radiobuttonModifyACLs.add_CheckedChanged($radiobuttonModifyACLs_CheckedChanged)
	#
	# buttonSetUpdateCredential
	#
	$buttonSetUpdateCredential.Location = '534, 103'
	$buttonSetUpdateCredential.Name = 'buttonSetUpdateCredential'
	$buttonSetUpdateCredential.Size = '116, 32'
	$buttonSetUpdateCredential.TabIndex = 30
	$buttonSetUpdateCredential.Text = 'Set Update Credential'
	$buttonSetUpdateCredential.UseCompatibleTextRendering = $True
	$buttonSetUpdateCredential.UseVisualStyleBackColor = $True
	$buttonSetUpdateCredential.add_Click($buttonSetUpdateCredential_Click)
	#
	# buttonRun
	#
	$buttonRun.BackColor = 'Red'
	$buttonRun.Enabled = $False
	$buttonRun.ForeColor = 'ActiveCaptionText'
	$buttonRun.Location = '534, 34'
	$buttonRun.Name = 'buttonRun'
	$buttonRun.Size = '116, 53'
	$buttonRun.TabIndex = 29
	$buttonRun.Text = 'Run'
	$buttonRun.UseCompatibleTextRendering = $True
	$buttonRun.UseVisualStyleBackColor = $False
	$buttonRun.add_Click($buttonRun_Click)
	#
	# listboxVMUpdateList
	#
	$listboxVMUpdateList.FormattingEnabled = $True
	$listboxVMUpdateList.Location = '403, 150'
	$listboxVMUpdateList.Name = 'listboxVMUpdateList'
	$listboxVMUpdateList.Size = '247, 225'
	$listboxVMUpdateList.TabIndex = 28
	#
	# listboxVMList
	#
	$listboxVMList.FormattingEnabled = $True
	$listboxVMList.Location = '8, 149'
	$listboxVMList.Name = 'listboxVMList'
	$listboxVMList.SelectionMode = 'MultiExtended'
	$listboxVMList.Size = '244, 225'
	$listboxVMList.TabIndex = 27
	$listboxVMList.add_SelectedIndexChanged($listboxVMList_SelectedIndexChanged)
	#
	# checkboxSelectAll
	#
	$checkboxSelectAll.Enabled = $False
	$checkboxSelectAll.Location = '8, 119'
	$checkboxSelectAll.Name = 'checkboxSelectAll'
	$checkboxSelectAll.Size = '86, 26'
	$checkboxSelectAll.TabIndex = 26
	$checkboxSelectAll.Text = 'Select All'
	$checkboxSelectAll.UseCompatibleTextRendering = $True
	$checkboxSelectAll.UseVisualStyleBackColor = $True
	$checkboxSelectAll.add_CheckedChanged($checkboxSelectAll_CheckedChanged)
	#
	# comboboxDatacenter
	#
	$comboboxDatacenter.DropDownStyle = 'DropDownList'
	$comboboxDatacenter.FormattingEnabled = $True
	$comboboxDatacenter.Location = '73, 46'
	$comboboxDatacenter.Name = 'comboboxDatacenter'
	$comboboxDatacenter.Size = '179, 21'
	$comboboxDatacenter.TabIndex = 24
	$comboboxDatacenter.add_SelectedIndexChanged($comboboxDatacenter_SelectedIndexChanged)
	#
	# labelDatacenter
	#
	$labelDatacenter.AutoSize = $True
	$labelDatacenter.Location = '8, 46'
	$labelDatacenter.Margin = '1, 0, 1, 0'
	$labelDatacenter.Name = 'labelDatacenter'
	$labelDatacenter.Size = '63, 17'
	$labelDatacenter.TabIndex = 23
	$labelDatacenter.Text = 'Datacenter:'
	$labelDatacenter.UseCompatibleTextRendering = $True
	#
	# labelVMFolder
	#
	$labelVMFolder.AutoSize = $True
	$labelVMFolder.Location = '8, 84'
	$labelVMFolder.Margin = '1, 0, 1, 0'
	$labelVMFolder.Name = 'labelVMFolder'
	$labelVMFolder.Size = '59, 17'
	$labelVMFolder.TabIndex = 22
	$labelVMFolder.Text = 'VM Folder:'
	$labelVMFolder.UseCompatibleTextRendering = $True
	#
	# comboboxVMFolders
	#
	$comboboxVMFolders.DropDownStyle = 'DropDownList'
	$comboboxVMFolders.FormattingEnabled = $True
	$comboboxVMFolders.Location = '73, 82'
	$comboboxVMFolders.Name = 'comboboxVMFolders'
	$comboboxVMFolders.Size = '179, 21'
	$comboboxVMFolders.Sorted = $True
	$comboboxVMFolders.TabIndex = 21
	$comboboxVMFolders.add_SelectedIndexChanged($comboboxVMFolders_SelectedIndexChanged)
	#
	# buttonDeleteVMFromQueue
	#
	$buttonDeleteVMFromQueue.Enabled = $False
	$buttonDeleteVMFromQueue.Location = '277, 261'
	$buttonDeleteVMFromQueue.Name = 'buttonDeleteVMFromQueue'
	$buttonDeleteVMFromQueue.Size = '100, 48'
	$buttonDeleteVMFromQueue.TabIndex = 19
	$buttonDeleteVMFromQueue.Text = '<--
Delete VM from Queue'
	$buttonDeleteVMFromQueue.UseCompatibleTextRendering = $True
	$buttonDeleteVMFromQueue.UseVisualStyleBackColor = $True
	$buttonDeleteVMFromQueue.add_Click($buttonDeleteVMFromQueue_Click)
	#
	# buttonAddVirtualMachines
	#
	$buttonAddVirtualMachines.Enabled = $False
	$buttonAddVirtualMachines.Location = '277, 184'
	$buttonAddVirtualMachines.Name = 'buttonAddVirtualMachines'
	$buttonAddVirtualMachines.Size = '100, 52'
	$buttonAddVirtualMachines.TabIndex = 18
	$buttonAddVirtualMachines.Text = '-->
Add Virtual Machines'
	$buttonAddVirtualMachines.UseCompatibleTextRendering = $True
	$buttonAddVirtualMachines.UseVisualStyleBackColor = $True
	$buttonAddVirtualMachines.add_Click($buttonAddVirtualMachines_Click)
	#
	# labelStep2
	#
	$labelStep2.AutoSize = $True
	$labelStep2.Font = 'Microsoft Sans Serif, 12pt, style=Bold'
	$labelStep2.Location = '8, 8'
	$labelStep2.Name = 'labelStep2'
	$labelStep2.Size = '224, 24'
	$labelStep2.TabIndex = 17
	$labelStep2.Text = 'Step 2: Select VMs to modify'
	$labelStep2.UseCompatibleTextRendering = $True
	#
	# buttonNext
	#
	$buttonNext.Anchor = 'Bottom, Right'
	$buttonNext.Location = '440, 420'
	$buttonNext.Name = 'buttonNext'
	$buttonNext.Size = '75, 23'
	$buttonNext.TabIndex = 2
	$buttonNext.Text = '&Next >'
	$buttonNext.UseCompatibleTextRendering = $True
	$buttonNext.UseVisualStyleBackColor = $True
	$buttonNext.add_Click($buttonNext_Click)
	$tabpageStep2.ResumeLayout()
	$panel1.ResumeLayout()
	$tabpageStep1.ResumeLayout()
	$tabcontrolWizard.ResumeLayout()
	$formVMToolsMitigation.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $formVMToolsMitigation.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$formVMToolsMitigation.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$formVMToolsMitigation.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$formVMToolsMitigation.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $formVMToolsMitigation.ShowDialog()

}
#endregion Source: MainForm.psf

#region Source: Functions\Get-FolderByPath.ps1
function Invoke-Get-FolderByPath_ps1
{
	function Get-FolderByPath
	{
	<#
	 .SYNOPSIS Retrieve folders by giving a path
	 .DESCRIPTION The function will retrieve a folder by it's path.
	   The path can contain any type of leave (folder or datacenter).
	 .NOTES
	   Author: Luc Dekens .PARAMETER Path The path to the folder. This is a required parameter.
	 .PARAMETER
	   Path The path to the folder. This is a required parameter.
	 .PARAMETER
	   Separator The character that is used to separate the leaves in the path. The default is '/'
	 .EXAMPLE
	   PS> Get-FolderByPath -Path "Folder1/Datacenter/Folder2"
	 .EXAMPLE
	   PS> Get-FolderByPath -Path "Folder1>Folder2" -Separator '>'
	#>
		
		param (
			[CmdletBinding()]
			[parameter(Mandatory = $true)]
			[System.String[]]${Path},
			[char]${Separator} = '/'
		)
		
		process
		{
			if ((Get-PowerCLIConfiguration).DefaultVIServerMode -eq "Multiple")
			{
				$vcs = $global:defaultVIServers
			}
			else
			{
				$vcs = $global:defaultVIServers[0]
			}
			
			foreach ($vc in $vcs)
			{
				$si = Get-View ServiceInstance -Server $vc
				$rootName = (Get-View -Id $si.Content.RootFolder -Property Name).Name
				foreach ($strPath in $Path)
				{
					$root = Get-Folder -Name $rootName -Server $vc -ErrorAction SilentlyContinue
					$strPath.Split($Separator) | %{
						$root = Get-Inventory -Name $_ -Location $root -Server $vc -ErrorAction SilentlyContinue
						if ((Get-Inventory -Location $root -NoRecursion | Select -ExpandProperty Name) -contains "vm")
						{
							$root = Get-Inventory -Name "vm" -Location $root -Server $vc -NoRecursion
						}
					}
					$root | where { $_ -is [VMware.VimAutomation.ViCore.Impl.V1.Inventory.FolderImpl] } | %{
						Get-Folder -Name $_.Name -Location $root.Parent -NoRecursion -Server $vc
					}
				}
			}
		}
	}
}
#endregion Source: Get-FolderByPath.ps1

#region Source: Functions\Get-Hash.ps1
function Invoke-Get-Hash_ps1
{
	<#
	.SYNOPSIS
	Gets the hash value of a file or string
	
	.DESCRIPTION
	Gets the hash value of a file or string
	It uses System.Security.Cryptography.HashAlgorithm (http://msdn.microsoft.com/en-us/library/system.security.cryptography.hashalgorithm.aspx)
	and FileStream Class (http://msdn.microsoft.com/en-us/library/system.io.filestream.aspx)
	Based on: http://blog.brianhartsock.com/2008/12/13/using-powershell-for-md5-checksums/ and some ideas on Microsoft Online Help
	
	Be aware, to avoid confusions, that if you use the pipeline, the behaviour is the same as using -Text, not -File
	
	.PARAMETER File
	File to get the hash from.
	
	.PARAMETER Text
	Text string to get the hash from
	
	.PARAMETER Algorithm
	Type of hash algorithm to use. Default is SHA1
	
	.EXAMPLE
	C:\PS> Get-Hash "hello_world.txt"
	Gets the SHA1 from myFile.txt file. When there's no explicit parameter, it uses -File
	
	.EXAMPLE
	Get-Hash -File "C:\temp\hello_world.txt"
	Gets the SHA1 from myFile.txt file
	
	.EXAMPLE
	C:\PS> Get-Hash -Algorithm "MD5" -Text "Hello Wold!"
	Gets the MD5 from a string
	
	.EXAMPLE
	C:\PS> "Hello Wold!" | Get-Hash
	We can pass a string throught the pipeline
	
	.EXAMPLE
	Get-Content "c:\temp\hello_world.txt" | Get-Hash
	It gets the string from Get-Content
	
	.EXAMPLE
	Get-ChildItem "C:\temp\*.txt" | %{ Write-Output "File: $($_)   has this hash: $(Get-Hash $_)" }
	This is a more complex example gets the hash of all "*.tmp" files
	
	.NOTES
	DBA daily stuff (http://dbadailystuff.com) by Josep Martínez Vilà
	Licensed under a Creative Commons Attribution 3.0 Unported License
	
	.LINK
	Original post: https://dbadailystuff.com/2013/03/11/get-hash-a-powershell-hash-function/
	#>
	function Get-Hash
	{
		Param
		(
			[parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = "set1")]
			[String]$text,
			[parameter(Position = 0, Mandatory = $true,
					   ValueFromPipeline = $false, ParameterSetName = "set2")]
			[String]$file = "",
			[parameter(Mandatory = $false, ValueFromPipeline = $false)]
			[ValidateSet("MD5", "SHA", "SHA1", "SHA-256", "SHA-384", "SHA-512")]
			[String]$algorithm = "SHA1"
		)
		Begin
		{
			$hashAlgorithm = [System.Security.Cryptography.HashAlgorithm]::Create($algorithm)
		}
		Process
		{
			$md5StringBuilder = New-Object System.Text.StringBuilder 50
			$ue = New-Object System.Text.UTF8Encoding
			
			if ($file)
			{
				try
				{
					if (!(Test-Path -literalpath $file))
					{
						throw "Test-Path returned false."
					}
				}
				catch
				{
					throw "Get-Hash - File not found or without permisions: [$file]. $_"
				}
				try
				{
					[System.IO.FileStream]$fileStream = [System.IO.File]::Open($file, [System.IO.FileMode]::Open);
					$hashAlgorithm.ComputeHash($fileStream) |
					% { [void]$md5StringBuilder.Append($_.ToString("x2")) }
				}
				catch
				{
					throw "Get-Hash - Error reading or hashing the file: [$file]"
				}
				finally
				{
					$fileStream.Close()
					$fileStream.Dispose()
				}
			}
			else
			{
				$hashAlgorithm.ComputeHash($ue.GetBytes($text)) |
				% { [void]$md5StringBuilder.Append($_.ToString("x2")) }
			}
			
			return $md5StringBuilder.ToString()
		}
	}
}
#endregion Source: Get-Hash.ps1

#region Source: Functions\InstallPreReqs.ps1
function Invoke-InstallPreReqs_ps1
{
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
		 Created on:   	4/9/2019 5:13 PM
		 Created by:   	andy-user
		 Organization: 	
		 Filename:     	
		===========================================================================
		.DESCRIPTION
			A description of the file.
	#>
	
	function Install-PreReqs
	{
		try
		{
			# Check if the PowerCLI PoSH module is installed. If it is not, install it.
			
			if (-not (Get-InstalledModule -Name "VMware.PowerCLI" -ErrorAction SilentlyContinue))
			{
				try
				{
					Set-ExecutionPolicy Unrestricted -Force
					Write-Host "Installing PowerCLI and PendingReboot modules on" $computer -ForegroundColor Yellow
					Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force
					Set-PSRepository -Name "PSGallery" -InstallationPolicy Trusted
					Install-Module -Name "VMWare.PowerCLI" -MaximumVersion 11.5.0.14912921 -Force -Scope AllUsers
					Write-Host "All required modules successfully installed." -ForegroundColor Green
					Import-Module VMware.PowerCLI
					Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false
					Set-PowerCLIConfiguration -ParticipateInCeip $false -Scope AllUsers -Confirm:$false
				}
				catch
				{
					
					Write-Host "Unable to install one or more modules. Please install manually or resolve connectivity issues." -ForegroundColor Red
				}
			}
			elseif (-not (Get-InstalledModule -Name "VMware.PowerCLI" -MinimumVersion 11.5.0.14912921 -ErrorAction SilentlyContinue))
			{
				Write-Host "All required modules are already installed, but less than the required version. Checking for module updates." -ForegroundColor Green
				try
				{
					Set-ExecutionPolicy Unrestricted -Force
					Update-Module -Name "VMware.PowerCLI" -Force -Confirm:$false -MaximumVersion 11.5.0.14912921 -ErrorAction SilentlyContinue
					Write-Host "All required modules are up to date." -ForegroundColor Green
					Import-Module VMWare.PowerCLI
					Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false
					Set-PowerCLIConfiguration -ParticipateInCeip $false -Scope AllUsers -Confirm:$false
				}
				catch
				{
					Write-Host "Unable to update one or more modules. Please install manually or resolve connectivity issues." -ForegroundColor Red
				}
			}
			
		} # End try statement.
		catch
		{
			"Unable to execute."
		} # End catch statement.
		
	}
}
#endregion Source: InstallPreReqs.ps1

#region Source: Functions\Get-FolderPath.ps1
function Invoke-Get-FolderPath_ps1
{
	function Get-FolderPath
	{
	<#
	.SYNOPSIS
		Returns the folderpath for a folder
	.DESCRIPTION
		The function will return the complete folderpath for
		a given folder, optionally with the "hidden" folders
		included. The function also indicats if it is a "blue"
		or "yellow" folder.
	.NOTES
		Authors:	Luc Dekens
	.PARAMETER Folder
		On or more folders
	.PARAMETER ShowHidden
		Switch to specify if "hidden" folders should be included
		in the returned path. The default is $false.
	.EXAMPLE
		PS> Get-FolderPath -Folder (Get-Folder -Name "MyFolder")
	.EXAMPLE
		PS> Get-Folder | Get-FolderPath -ShowHidden:$true
	#>
		
		param (
			[parameter(valuefrompipeline = $true,
					   position = 0,
					   HelpMessage = "Enter a folder")]
			[VMware.VimAutomation.ViCore.Impl.V1.Inventory.FolderImpl[]]$Folder,
			[switch]$ShowHidden = $false
		)
		
		begin
		{
			$excludedNames = "Datacenters", "vm", "host"
		}
		
		process
		{
			$Folder | %{
				$fld = $_.Extensiondata
				$fldType = "yellow"
				if ($fld.ChildType -contains "VirtualMachine")
				{
					$fldType = "blue"
				}
				$path = $fld.Name
				while ($fld.Parent)
				{
					$fld = Get-View $fld.Parent
					if ((!$ShowHidden -and $excludedNames -notcontains $fld.Name) -or $ShowHidden)
					{
						$path = $fld.Name + "\" + $path
					}
				}
				$row = "" | Select Name, Path, Type
				$row.Name = $_.Name
				$row.Path = $path
				$row.Type = $fldType
				$row
			}
		}
	}
	
	
}
#endregion Source: Get-FolderPath.ps1

#region Source: Functions\Test-TCPport.ps1
function Invoke-Test-TCPport_ps1
{
	function Test-TCPport 
	{
	    Param([parameter(Mandatory=$true,ValueFromPipeline=$True)][string[]]$ComputerName,
	            [parameter(Mandatory=$true,ValueFromPipeline=$True)]$TCPport
	    )
	
	    $requestCallback = $state = $null
	    $client = New-Object System.Net.Sockets.TcpClient
	    $beginConnect = $client.BeginConnect($ComputerName,$TCPport,$requestCallback,$state)
	    Start-Sleep -Milliseconds 500
	    if ($client.Connected) 
	    {
	        $open = $true
	    } 
	    else
	    {
	        $open = $false            
	    }
	
	    $client.Close()
	        
	    [pscustomobject]@{hostname=$ComputerName;port=$TCPport;open=$open}
	}
}
#endregion Source: Test-TCPport.ps1

#region Source: Functions\Set-Owner.ps1
function Invoke-Set-Owner_ps1
{
	Function Set-Owner
	{
	    <#
	        .SYNOPSIS
	            Changes owner of a file or folder to another user or group.
	
	        .DESCRIPTION
	            Changes owner of a file or folder to another user or group.
	
	        .PARAMETER Path
	            The folder or file that will have the owner changed.
	
	        .PARAMETER Account
	            Optional parameter to change owner of a file or folder to specified account.
	
	            Default value is 'Builtin\Administrators'
	
	        .PARAMETER Recurse
	            Recursively set ownership on subfolders and files beneath given folder.
	
	        .NOTES
	            Name: Set-Owner
	            Author: Boe Prox
	            Version History:
	                 1.0 - Boe Prox
	                    - Initial Version
	
	        .EXAMPLE
	            Set-Owner -Path C:\temp\test.txt
	
	            Description
	            -----------
	            Changes the owner of test.txt to Builtin\Administrators
	
	        .EXAMPLE
	            Set-Owner -Path C:\temp\test.txt -Account 'Domain\bprox
	
	            Description
	            -----------
	            Changes the owner of test.txt to Domain\bprox
	
	        .EXAMPLE
	            Set-Owner -Path C:\temp -Recurse 
	
	            Description
	            -----------
	            Changes the owner of all files and folders under C:\Temp to Builtin\Administrators
	
	        .EXAMPLE
	            Get-ChildItem C:\Temp | Set-Owner -Recurse -Account 'Domain\bprox'
	
	            Description
	            -----------
	            Changes the owner of all files and folders under C:\Temp to Domain\bprox
	    #>
		[cmdletbinding(
					   SupportsShouldProcess = $True
					   )]
		Param (
			[parameter(ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
			[Alias('FullName')]
			[string[]]$Path,
			[parameter()]
			[string]$Account = 'Builtin\Administrators',
			[parameter()]
			[switch]$Recurse
		)
		Begin
		{
			#Prevent Confirmation on each Write-Debug command when using -Debug
			If ($PSBoundParameters['Debug'])
			{
				$DebugPreference = 'Continue'
			}
			Try
			{
				[void][TokenAdjuster]
			}
			Catch
			{
				$AdjustTokenPrivileges = @"
            using System;
            using System.Runtime.InteropServices;

             public class TokenAdjuster
             {
              [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
              internal static extern bool AdjustTokenPrivileges(IntPtr htok, bool disall,
              ref TokPriv1Luid newst, int len, IntPtr prev, IntPtr relen);
              [DllImport("kernel32.dll", ExactSpelling = true)]
              internal static extern IntPtr GetCurrentProcess();
              [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
              internal static extern bool OpenProcessToken(IntPtr h, int acc, ref IntPtr
              phtok);
              [DllImport("advapi32.dll", SetLastError = true)]
              internal static extern bool LookupPrivilegeValue(string host, string name,
              ref long pluid);
              [StructLayout(LayoutKind.Sequential, Pack = 1)]
              internal struct TokPriv1Luid
              {
               public int Count;
               public long Luid;
               public int Attr;
              }
              internal const int SE_PRIVILEGE_DISABLED = 0x00000000;
              internal const int SE_PRIVILEGE_ENABLED = 0x00000002;
              internal const int TOKEN_QUERY = 0x00000008;
              internal const int TOKEN_ADJUST_PRIVILEGES = 0x00000020;
              public static bool AddPrivilege(string privilege)
              {
               try
               {
                bool retVal;
                TokPriv1Luid tp;
                IntPtr hproc = GetCurrentProcess();
                IntPtr htok = IntPtr.Zero;
                retVal = OpenProcessToken(hproc, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ref htok);
                tp.Count = 1;
                tp.Luid = 0;
                tp.Attr = SE_PRIVILEGE_ENABLED;
                retVal = LookupPrivilegeValue(null, privilege, ref tp.Luid);
                retVal = AdjustTokenPrivileges(htok, false, ref tp, 0, IntPtr.Zero, IntPtr.Zero);
                return retVal;
               }
               catch (Exception ex)
               {
                throw ex;
               }
              }
              public static bool RemovePrivilege(string privilege)
              {
               try
               {
                bool retVal;
                TokPriv1Luid tp;
                IntPtr hproc = GetCurrentProcess();
                IntPtr htok = IntPtr.Zero;
                retVal = OpenProcessToken(hproc, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ref htok);
                tp.Count = 1;
                tp.Luid = 0;
                tp.Attr = SE_PRIVILEGE_DISABLED;
                retVal = LookupPrivilegeValue(null, privilege, ref tp.Luid);
                retVal = AdjustTokenPrivileges(htok, false, ref tp, 0, IntPtr.Zero, IntPtr.Zero);
                return retVal;
               }
               catch (Exception ex)
               {
                throw ex;
               }
              }
             }
"@
				Add-Type $AdjustTokenPrivileges
			}
			
			#Activate necessary admin privileges to make changes without NTFS perms
			[void][TokenAdjuster]::AddPrivilege("SeRestorePrivilege") #Necessary to set Owner Permissions
			[void][TokenAdjuster]::AddPrivilege("SeBackupPrivilege") #Necessary to bypass Traverse Checking
			[void][TokenAdjuster]::AddPrivilege("SeTakeOwnershipPrivilege") #Necessary to override FilePermissions
		}
		Process
		{
			ForEach ($Item in $Path)
			{
				Write-Verbose "FullName: $Item"
				#The ACL objects do not like being used more than once, so re-create them on the Process block
				$DirOwner = New-Object System.Security.AccessControl.DirectorySecurity
				$DirOwner.SetOwner([System.Security.Principal.NTAccount]$Account)
				$FileOwner = New-Object System.Security.AccessControl.FileSecurity
				$FileOwner.SetOwner([System.Security.Principal.NTAccount]$Account)
				$DirAdminAcl = New-Object System.Security.AccessControl.DirectorySecurity
				$FileAdminAcl = New-Object System.Security.AccessControl.DirectorySecurity
				$AdminACL = New-Object System.Security.AccessControl.FileSystemAccessRule('Builtin\Administrators', 'FullControl', 'ContainerInherit,ObjectInherit', 'InheritOnly', 'Allow')
				$FileAdminAcl.AddAccessRule($AdminACL)
				$DirAdminAcl.AddAccessRule($AdminACL)
				Try
				{
					$Item = Get-Item -LiteralPath $Item -Force -ErrorAction Stop
					If (-NOT $Item.PSIsContainer)
					{
						If ($PSCmdlet.ShouldProcess($Item, 'Set File Owner'))
						{
							Try
							{
								$Item.SetAccessControl($FileOwner)
							}
							Catch
							{
								Write-Warning "Couldn't take ownership of $($Item.FullName)! Taking FullControl of $($Item.Directory.FullName)"
								$Item.Directory.SetAccessControl($FileAdminAcl)
								$Item.SetAccessControl($FileOwner)
							}
						}
					}
					Else
					{
						If ($PSCmdlet.ShouldProcess($Item, 'Set Directory Owner'))
						{
							Try
							{
								$Item.SetAccessControl($DirOwner)
							}
							Catch
							{
								Write-Warning "Couldn't take ownership of $($Item.FullName)! Taking FullControl of $($Item.Parent.FullName)"
								$Item.Parent.SetAccessControl($DirAdminAcl)
								$Item.SetAccessControl($DirOwner)
							}
						}
						If ($Recurse)
						{
							[void]$PSBoundParameters.Remove('Path')
							Get-ChildItem $Item -Force | Set-Owner @PSBoundParameters
						}
					}
				}
				Catch
				{
					Write-Warning "$($Item): $($_.Exception.Message)"
				}
			}
		}
		End
		{
			#Remove priviledges that had been granted
			[void][TokenAdjuster]::RemovePrivilege("SeRestorePrivilege")
			[void][TokenAdjuster]::RemovePrivilege("SeBackupPrivilege")
			[void][TokenAdjuster]::RemovePrivilege("SeTakeOwnershipPrivilege")
		}
	}
	
}
#endregion Source: Set-Owner.ps1

#Start the application
Main ($CommandLine)
